#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass report
\use_default_options false
\language english
\inputencoding latin9
\font_roman default
\font_sans default
\font_typewriter lmtt
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing double
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
\paragraph_spacing double
Implementation
\end_layout

\begin_layout Section
The Agents
\end_layout

\begin_layout Standard
Taxis and Fares are subclasses of a common Agent class.
 The Agent class sets a mapping type to either grid or graph and sets the
 Agent's initial location on the grid or graph, respectively.
 The Agent also defines a queue to hold waiting Fares.
 It is a class attribute that holds only Fares, but it is used by both Agent
 types.
 The Taxi queries this list when it decides what to do next.
 Exactly what the Taxi is looking for is dependent on which negotiation
 protocol (FIFO, closestFare or mixedMode) and which simulation type (competitiv
e or cooperative) are running.
\end_layout

\begin_layout Standard
The Agent also subclasses SimPy's Process class, which provides a means
 for SimPy to manipulate the Agents during discrete-event simulation.
 Process objects must provide a method called the Process Execution Method
 (PEM) that is invoked by the simulation toolkit to activate the object.
 When the PEM exits, the Process object is destroyed.
 The PEM is where the simulated object's behaviors are defined.
 
\end_layout

\begin_layout Standard
The lifecycle of a Fare is simple.
 It begins when the Fare is created, and ends when it is dropped off at
 its destination by a Taxi, or the simulation ends, whichever comes first.
 Fares are created throughout the simulation.
 Their generation rate is configurable; it is the inverse of an exponential
 distribution (see meanFareGenerationRate in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-agents-default.ini"

\end_inset

).
 The Fare uses the same PEM for all simulations.
 It collects timestamped event data starting with the initial request for
 pickup; then again when it is picked up; and finally when it is dropped
 off.
\end_layout

\begin_layout Standard
The waitingFares queue holds references to Fare objects.
 But when referring to the contents of the queue, I use Fare and request
 interchangeably.
 They are equivalent for documentation purposes.
\begin_inset Foot
status open

\begin_layout Plain Layout
One of the difficulties that came up during data collection for analysis
 was accounting for Fares that are left in the wait queue at the end of
 the simulation.
 This is covered in the results section.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Taxi class is more complex than the Fares, as it defines multiple SimPy
 PEMs corresponding to the different negotiation protocols and simulation
 types.
 Leaving the NPs and simtypes aside for now, the lifecycle of the Taxis
 is complementary to that of the Fares.
 Taxis are created at the beginning of the simulation, and persist until
 the simulation ends.
 They normally pick up several Fares, but only one at a time.
 They do the kind of things you'd expect: wait for a request for pickup;
 either negotiate or compete to pick up the Fare; pick up the Fare; drive
 to the requested destination; update the location of both Agents; notify
 the Fare when the destination is reached; and then start the whole cycle
 over again.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
TODO Add something about possible enhancements (maybe in the results section?)
 about picking up multiple Fares at more than one stop during a Taxi run.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The details of the cooperating Taxis is mostly independent of which negotiation
 protocol is used.
 What matters is that at some point the Taxi identifies a Fare for pickup.
 The Taxi takes a reference to the Fare, and removes it from the waitingFares
 queue.
 Note, this is before the Taxi has 
\begin_inset Quotes eld
\end_inset

driven
\begin_inset Quotes erd
\end_inset

 to the Fare.
 This scheme does not work with the competing Taxis, which handle Fare pickups
 differently.
\end_layout

\begin_layout Standard
Competing Taxis have a different set of issues.
 Again leaving aside details about the NPs, eventually a Taxi will identify
 a Fare for which he would like to compete.
 Taxis identify themselves as competing for a specific target Fare by entering
 a compete queue that is maintained by the system on behalf of a Fare.
 Taxis are eligible to enter one compete queue at a time, 
\begin_inset Foot
status open

\begin_layout Plain Layout
In other words, a Taxi may not compete for more than one Fare at a time.
\end_layout

\end_inset

 and may enter a compete queue at any time after the Fare's initial request
 for pickup, until the Fare is 
\begin_inset Quotes eld
\end_inset

won
\begin_inset Quotes erd
\end_inset

 or claimed by a Taxi.
 The winning Taxi announces his arrival to the other competitors, who then
 look for another Fare for which to compete.
 Meanwhile, the winning Taxi drives to the Fare's destination.
\end_layout

\begin_layout Standard
Taxis have only partial knowledge of their world.
 This is most noticeable during competition.
 The negotiation protocols largely dictate which Taxis receive pickup requests
 from the Fares.
 In addition, Taxis are essentially blind to the number and location of
 their competitors, and stay that way the whole time.
 A winning Taxi sends a broadcast to announce he's won, but he does not
 know who receives it.
 Likewise, the receiving Taxis don't know who else has received it, or even
 who sent it.
 All they know is that they did or did not win the Fare.
\end_layout

\begin_layout Standard
Other interesting things occur as a result of the autonomous agent's incomplete
 system knowledge.
 An earlier version of the program had an additional signal event when the
 Fare received an acknowledgment of pending pickup from the Taxi.
 This only made sense with cooperative simulations due to the way the Taxis
 process pickup requests, so I left it out.
 While a Taxi is en-route with a Fare, it may receive requests for pickup,
 but may not act on them.
 So while a Taxi may be the first one available for hire, he may not necessarily
 be the first one to reach the Fare, since another Taxi may be closer to
 the Fare, but currently ineligible to respond.
 If the second Taxi drops off his Fare and reaches the Fare first, the first
 Taxi's acknowledgment would be considered an error, based on his limited
 knowledge of the other Agents.
\end_layout

\begin_layout Section
Negotiation Protocols
\end_layout

\begin_layout Standard
There are three negotiation protocols (my phrase).
 They are similar in concept, but with different implementations, for the
 cooperative and competitive simulations.
 A simulation must use exactly one of them.
 It is specified in the agent configuration file 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:The-agents-default.ini"

\end_inset

.
 The NPs control how the Fares broadcast their pickup requests, and how
 the Taxis decide who will make the pickup.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This sounds like intro material.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The simplest NP is FIFO, or first-in, first-out, for cooperative simulations.
 As Fares enter the simulation and broadcast pickup requests, they are pushed
 onto the queue.
 Taxis take Fares in the order in which they become available to accept
 requests, typically after dropping off their current Fare.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
At the start of the simulation there are generally more Taxis than Fares,
 so some Taxis wind up waiting around for something to do while the system
 generates work for all.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
FIFO turns out to be a good baseline for comparison with other simulations.
 It is simple but inefficient.
 The distances that the Taxis drive to make pickups is not taken into considerat
ion at all.
\begin_inset Note Note
status open

\begin_layout Plain Layout
This sounds like conclusion material.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the other hand, it is easy to trace
\end_layout

\begin_layout Standard
they regardless of thierare freed up to make another They are removed from
 the queue in the order in which they are entered.
 A Fare is taken to it's destination after being 
\begin_inset Quotes eld
\end_inset

picked up
\begin_inset Quotes erd
\end_inset

, as signalled by being removed from the queue.
 FIFO does not 
\end_layout

\begin_layout Standard
[LIMERICK 1] There once was a man from Ghent
\end_layout

\begin_layout Section
Cooperative and Competitive Simulations
\end_layout

\begin_layout Standard
[LIMERICK 2] Who had a penis so long it bent
\end_layout

\begin_layout Section
Grids and Graphs
\end_layout

\begin_layout Standard
[LIMERICK 3] It was so much trouble
\end_layout

\begin_layout Enumerate
\paragraph_spacing double
data prep - grid
\end_layout

\begin_layout Enumerate
\paragraph_spacing double
data prep - graphs
\end_layout

\begin_deeper
\begin_layout Enumerate
\paragraph_spacing double
get FIPS
\end_layout

\begin_layout Enumerate
\paragraph_spacing double
process lat/lon data
\end_layout

\begin_layout Enumerate
\paragraph_spacing double
make graph
\end_layout

\begin_deeper
\begin_layout Enumerate
\paragraph_spacing double
describe algorithm for connecting nodes
\end_layout

\end_deeper
\begin_layout Enumerate
\paragraph_spacing double
little bit of graph theory
\end_layout

\begin_deeper
\begin_layout Enumerate
\paragraph_spacing double
streets and roads are [ 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 ]
\end_layout

\begin_layout Enumerate
\paragraph_spacing double
intersections are [ 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 ]
\end_layout

\begin_layout Enumerate
\paragraph_spacing double
slightly fuzzy math (but well within tolerance of size of intersection).
 IOW, if lat/lon data is good to 6 decimal places, that equates to a length
 of, say, 3 feet.
 But an intersection is at least 20 feet across, so the accuracy is good
 enough to correctly locate each [ node or vertex ] intersection as equating
 to a geographical (street level) intersection.
\end_layout

\end_deeper
\begin_layout Enumerate
\paragraph_spacing double
generating plots
\end_layout

\end_deeper
\begin_layout Section
Config parser
\end_layout

\begin_layout Standard
[LIMERICK 4] That he kept it double
\end_layout

\begin_layout Section
Some other section
\end_layout

\begin_layout Standard
[LIMERICK 5] And instead of coming he went.
\end_layout

\end_body
\end_document
